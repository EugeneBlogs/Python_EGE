# Условие задания КИМ 24 (Яндекс Учебник)
'''
Текстовый файл содержит цифры от 0 до 9.
Найдите длину самой длинной подстроки, состоящей из последовательности возрастающих
на единицу чисел, которая содержит число 78 как один из элементов.
Верной подстрокой считается непрерывная цепочка цифр, которую образуют числа,
идущие по порядку (например, "45464748" или "4567").
Например, для строки '12345678910111278156178798081828384' ответ будет 14,
так как самая длинная подстрока, подходящая под условие, "78798081828384",
содержит 14 цифр. Подстрока "123456789101112" не подходит, так как число 78
должно являться частью идущих по порядку чисел.
'''

f = open("13.txt")
s = f.readline()
# Найдём все индексы числа 78 в строке
indexes_78 = []
for i in range(len(s) - 1):
    if s[i] == "7":
        if s[i + 1] == "8":
            indexes_78.append(i)

count = 2
max_count = 0
# Проходимся по найденным индексам
for el in indexes_78:
    # Ожидаемое текущее число в смвольном виде и числовом
    current_number = ["7", "9"]
    num = 79
    add = 0
    # Цикл идёт начиная от индекса числа 78, но если быть конкретнее, от индекса цифры 7,
    # тогда прибавляем 2, чтобы перейти на символ после 8
    for i in range(int(el) + 2, len(s)):
        if s[i] == current_number[0]:  # Если текущий символ равен первому символу ожидаемого числа
            current_number.pop(0)  # Удаляем первый символ ожидаемого числа
            add += 1  # Теоретически, мы должны добавить 1 символ
            if not current_number:  # Если список опустел,
                count += add  # Можем точно добавить символы
                add = 0  # Обнуляем добавленные символы
                # Изменяем на +1 ожидаемое число
                num += 1
                current_number = [sym for sym in str(num)]
        else:  # Иначе, цепочка прервалась
            break
    # Перенастраиваемся на уменьшение
    current_number = ["7", "7"]
    num = 77
    add = 0
    # Аналогичный цикл в обратную сторону
    for i in range(int(el) - 1, 0, -1):
        if s[i] == current_number[-1]:  # Если текущий символ равен последнему символу ожидаемого числа
            current_number.pop(-1)  # Удаляем последний символ ожидаемого числа
            add += 1  # Теоретически, мы должны добавить 1 символ
            if not current_number:  # Если список опустел,
                count += add  # Можем точно добавить символы
                add = 0  # Обнуляем добавленные символы
                # Изменяем на -1 ожидаемое число
                num -= 1
                if num < 0:  # Если ожидаемое число пошло в отрицательные, то завершаем работу
                    max_count = max(max_count, count)
                    count = 2
                    break
                current_number = [sym for sym in str(num)]
        else:  # Иначе, цепочка прервалась
            max_count = max(max_count, count)  # Вычисляем максимум
            count = 2
            break
print(max_count)
