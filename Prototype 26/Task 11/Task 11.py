# Условие задания КИМ 26 (Умскул, Демоверсия 2026):
'''
Отдел маркетинга сети магазинов составляет рейтинг продуктов по информации об их сроках хранения с момента изготовления
и после вскрытия упаковки. Для каждого продукта известен срок его хранения с момента изготовления и срок годности
к употреблению после вскрытия упаковки. Продукты пронумерованы начиная с единицы. 
В рейтинговом списке маркетологи располагают продукты по следующему алгоритму:
- все "2N" чисел, обозначающих срок хранения и срок годности к употреблению для "N" продуктов, упорядочивают по возрастанию;
- если минимальное число в этом упорядоченном списке - срок хранения, то продукт в рейтинге занимает первое свободное
место от его начала;
- если минимальное число - срок годности к употреблению, то продукт занимает первое свободное место от конца рейтинга;
- если число обозначает срок хранения или срок годности к употреблению уже рассмотренного продукта, то его не принимают 
во внимание. 
Этот алгоритм применяется последовательно для размещения всех "N" продуктов.
Определите номер последнего продукта, для которого будет определено его место в рейтинге, и количество продуктов,
которые займут в рейтинге более низкие места.
 
Входные данные:
В первой строке входного файла находится натуральное число "N" ("N ≤ 1000") - количество продуктов.
Следующие "N" строк содержат пары чисел, обозначающих соответственно срок хранения продукта с момента изготовления
и срок годности к употреблению после вскрытия упаковки (все числа натуральные, различные).
Запишите в ответе два натуральных числа: сначала номер последнего продукта, для которого будет определено его место в
рейтинге, затем - количество продуктов, которые займут в рейтинге более низкие места.
'''

f = open("11.txt")
N = int(f.readline())
rating_start, rating_end = [], []  # Начало и конец рейтинга
for i in range(N):
    storage, use = map(int, f.readline().split())  # Считываем срок хранения и срок годности
    # Распределяем по рейтингу по условию
    if storage < use:
        rating_start.append([storage, i])
    else:
        rating_end.append([use, i])
# Максимальный номер будет в конце списка и добавляем 1 (так как нумерация была с 0)
print(max(rating_end)[1] + 1)
# Считаем все элементы в конце списка, кроме максимального номера (так как нужно места ниже его)
print(len(rating_end) - 1)
