# Условие задания КИМ 26 (Умскул, ЕГЭ 2025):
'''
При онлайн-покупке билета на концерт известно, какие места в зале уже заняты. Необходимо купить два билета на такие
соседние места в одном ряду, чтобы перед ними все кресла с такими же номерами были свободны, а ряд находился как можно
дальше от сцены. Если в этом ряду таких пар мест несколько, найдите пару с наибольшими номерами.
В ответе запишите два целых числа: искомый номер ряда и наибольший номер места в найденной паре.
Нумерация рядов и мест ведётся с 1. Гарантируется, что хотя бы одна такая пара в зале есть.

Входные данные:
В первой строке входного файла находятся три числа: "N" - количество занятых мест в зале (целое положительное число,
не превышающее 10000), "M" - количество рядов (целое положительное число, не превышающее 100000) и "K" - количество мест
в каждом ряду (целое положительное число, не превышающее 100000). В следующих "N" строках находятся пары натуральных
чисел: номер ряда и номер места занятого кресла соответственно (первое число не превышает значения "M", а второе - "K").

Выходные данные:
Два целых положительных числа: наибольший номер ряда и наибольший номер места в найденной паре кресел.

Типовой пример организации данных во входном файле:
7 7 8
1 1
6 6
5 5
6 7
4 4
2 2
3 3
При таких исходных данных ответом является пара чисел 5 и 8. Условию задачи удовлетворяют места 7 и 8 в ряду 5:
перед креслами 7 и 8 нет занятых мест и это последняя из двух возможных пар в этом ряду.
В рядах 6 и 7 искомую пару найти нельзя.
'''

f = open("10.txt")
N, M, K = map(int, f.readline().split())

# В массиве "places" для каждого места будем хранить минимальный номер ряда,
# в котором это место занято (изначально заполняем значением "M+1" - больше максимального возможного),
# индексы от 0 до K (места с 1 до K)
places = [M + 1] * (K + 1)

# Читаем "N" строк с занятыми местами и обновляем массив "places"
for i in range(N):
    row, place = map(int, f.readline().split())
    places[place] = min(places[place], row)  # Для каждого места запоминаем минимальный ряд, где оно занято

N_row = 0  # Максимальный подходящий номер ряда
N_place = []  # Подходящие места

# Перебираем все возможные пары соседних мест ("i" и "i+1")
for i in range(1, K):
    # Вычисляем минимальный ряд, где оба места в паре свободны (на 1 меньше занятого)
    current_row = min(places[i] - 1, places[i + 1] - 1)
    N_row = max(N_row, current_row)  # Обновляем максимальный подходящий ряд
    # Если текущая пара даёт ряд, равный максимальному найденному,
    # добавляем номер второго места в паре "(i+1)" в список
    if current_row == N_row:
        N_place.append(i + 1)

# Выводим результат: максимальный ряд и максимальное место из найденных пар
print(N_row, max(N_place))
