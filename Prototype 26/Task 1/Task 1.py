# Условие задания КИМ 26 (Умскул, Досрок 2024):
'''
В кондитерской есть "N" круглых форм для коржей. Специализация кондитерской - многоярусные торты, в которых диаметр
каждого верхнего коржа меньше диаметра предыдущего. Один корж можно поместить на другой, если его диаметр хотя бы
на 4 единицы меньше диаметра другого коржа. Определите наибольшее количество коржей, которое можно использовать
для создания многоярусного торта, и максимально возможный диаметр самого маленького коржа.

Входные данные:
В первой строке входного файла находится число "N" - количество форм для коржей в кондитерской
(натуральное число, не превышающее 10000). В следующих "N" строках находятся значения диаметров форм для коржей
(все числа натуральные, не превышающие 10000), каждое - в отдельной строке. Диаметр формы равен диаметру коржа,
который выпекается в этой в форме. Запишите в ответе два целых числа: сначала наибольшее количество коржей,
которое можно использовать для создания одного многоярусного торта, затем - максимально возможный диаметр самого
маленького коржа в таком торте.

Типовой пример организации данных во входном файле:
5
43
40
32
40
30
Пример входного файла приведён для пяти коржей и случая, когда минимальная допустимая разница между диаметрами коржей,
подходящих для изготовления многоярусного торта, составляет 3 единицы.
При таких исходных данных условию задачи удовлетворяют наборы коржей с диаметрами 30, 40 и 43 или 32, 40 и 43
соответственно, то есть количество коржей равно 3, а максимально возможный диаметр самого маленького коржа равен 32.
'''

f = open("1_1.txt")
N = int(f.readline())  # Считаем количество коржей
layers = [int(s) for s in f]  # Считываем диаметры коржей
# Сортируем значения по убыванию, чтобы в конце мы смогли определить максимальное значение самого маленького коржа
layers.sort(reverse=True)
cake = [layers[0]]  # Торт, по умолчанию добавляем самый большой корж
# Проходимся по остальным коржам, исключая самый большой (нулевой)
for layer in layers[1:]:
    # Проверяем, чтобы разность последнего коржа на торте (сверху) и текущего коржа была больше или равна 4
    if cake[-1] - layer >= 4:
        cake.append(layer)  # Добавляем новый корж
print(len(cake))  # Выводим наибольшее количество коржей
print(min(cake))  # Выводим максимально возможный диаметр самого маленького коржа

# Условие задания КИМ 26 (Умскул, ЕГЭ 2022, Демоверсия 2023):
'''
В магазине для упаковки подарков есть "N" кубических коробок. Самой интересной считается упаковка подарка по принципу
матрёшки - подарок упаковывается в одну из коробок, та в свою очередь в другую коробку и т. д.
Одну коробку можно поместить в другую, если длина её стороны хотя бы на 3 единицы меньше длины стороны другой коробки.
Определите наибольшее количество коробок, которое можно использовать для упаковки одного подарка,
и максимально возможную длину стороны самой маленькой коробки, где будет находиться подарок.
Размер подарка позволяет поместить его в самую маленькую коробку.

Входные данные:
В первой строке входного файла находится число "N" - количество коробок в магазине
(натуральное число, не превышающее 10000). В следующих "N" строках находятся значения длин сторон коробок
(все числа натуральные, не превышающие 10000), каждое - в отдельной строке.

Запишите в ответе два целых числа: сначала наибольшее количество коробок, которое можно использовать для упаковки
одного подарка, затем максимально возможную длину стороны самой маленькой коробки в таком наборе.

Пример входного файла:
5
43
40
32
40
30
Пример входного файла приведён для пяти коробок и случая, когда минимальная допустимая разница между
длинами сторон коробок, подходящих для упаковки «матрёшкой», составляет 3 единицы.
При таких исходных данных условию задачи удовлетворяют наборы коробок с длинами сторон 30, 40 и 43 или 32, 40 и 43
соответственно, то есть количество коробок равно 3, а длина стороны самой маленькой коробки равна 32.
'''

f = open("1_2.txt")
N = int(f.readline())
boxes = [int(s) for s in f.readlines()]
boxes.sort(reverse=True)

gift = [boxes[0]]
for box in boxes[1:]:
    if gift[-1] - box >= 3:
        gift.append(box)

print(len(gift), min(gift))
