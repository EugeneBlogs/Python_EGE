import math

file = open("../27_A.txt")  # Считываем данные из файла
file.readline()  # Считываем первую строку с заголовком
# Считываем данные: построчно, заменяя запятые на точки, разделяем числа по пробелам и конвертируем в дробные
points = [list(map(float, s.replace(",", ".").split())) for s in file]
clusters = []  # Список кластеров
# Гиперпараметр для сравнения расстояний между точками (нужно подобрать)
# Например, 0.5 в данной задаче создал слишком много кластеров, хотя по условию их 2, поэтому изменили на 1
# Вообще, чем меньше гиперпараметр, тем больше будет кластеров, и наоборот
epsilon = 1
# Работаем методом "DBSCAN"
# Пока есть точки:
while points:
    clusters.append([points[0]])  # Создаём кластер с любой точкой
    del points[0]  # Удаляем её из общего списка, так как она уже имеет свой кластер
    # Перебираем точки из последнего кластера:
    for p1 in clusters[-1]:
        # Перебираем точки, которые являются кандидатами в данный кластер:
        # Проходимся по копии списка ([:]), чтобы иметь возможность удалять точки по ходу прохождения из оригинала
        for p2 in points[:]:
            # Если расстояние между точками меньше нашего параметра, то они соседи, а значит находятся в одном кластере
            if math.dist(p1, p2) < epsilon:
                clusters[-1].append(p2)  # Добавляем данную точку в последний (текущий) кластер
                points.remove(p2)  # Удаляем её из общего списка

'''
Если бы в задаче были аномалии, то можно было бы проверить количество точек в кластере,
и удалить его, если точек меньше, чем нужно по условию
'''

# (НЕОБЯЗАТЕЛЬНО) Визуализируем данные для проверки

from turtle import *

k = 80  # Коэффициент для масштаба рисунка
colors = ["red", "blue", "green", "yellow", "cyan", "pink", "purple", "brown", "black"]  # Список цветов
screensize(2000, 2000)  # Размер экрана
tracer(0)  # Убираем анимацию, чтобы моментально отобразить рисунок
penup()  # Поднимаем кисть
# Проходимся по каждому кластеру:
for i in range(len(clusters)):
    # Проходимся по каждой точке кластера:
    for x, y in clusters[i]:
        setpos(x * k, y * k)  # Ставим курсор в нужную точку (с учётом коэффициента масштабирования)
        dot(5, colors[i])  # Ставим точку размера 5 и красим в соответствующий цвет
done()  # Выводим рисунок

best_centroids = [[] for _ in range(len(clusters))]  # Сколько кластеров, столько и центроидов
# Проходимся по каждому кластеру
for i in range(len(clusters)):
    min_sum_dist = 10 ** 10  # Минимальное суммарное расстояние
    # Проходимся по всем точкам какого-то кластера
    for x1, y1 in clusters[i]:
        sum_dist = 0  # Суммарное расстояние от точки до остальных точек
        # Ищем расстояние до всех точек этого кластера от текущей точки (включая саму себя)
        for x2, y2 in clusters[i]:
            sum_dist += math.dist([x1, y1], [x2, y2])  # Добавляем расстояние между точками
        # Если текущее суммарное расстояние меньше минимума, то обновляем значения
        if sum_dist < min_sum_dist:
            min_sum_dist = sum_dist
            best_centroids[i] = [x1, y1]

# Сумма всех координат "X", делённая на количество центроидов (или кластеров) и умноженная на 10_000 (по условию)
P_x = (sum([x for x, y in best_centroids]) / len(clusters)) * 10_000
# Аналогично для всех координат "Y"
P_y = (sum([y for x, y in best_centroids]) / len(clusters)) * 10_000

print(int(P_x), int(P_y))  # Выводим целые части ответов

