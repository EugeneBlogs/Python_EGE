# Условие задания КИМ 1 (Умскул):
'''
На рисунке изображена схема дорог N-ского района, в таблице звёздочкой обозначено наличие дороги из
дного населённого пункта в другой. Отсутствие звёздочки означает, что такой дороги нет.
(Файл "Prototype 1/Task 2/Condition 1.png")
Каждому населённому пункту на схеме соответствует его номер в таблице, но неизвестно, какой именно номер.
Определите, какие номера населённых пунктов в таблице могут соответствовать населённым пунктам "В" и "Е" на схеме.
В ответе запишите эти два номера в возрастающем порядке без пробелов и знаков препинания.
'''

from itertools import *  # Импортируем библиотеу для комбинаторики

# Переносим данные с рисунка в массивы
# Переносим все связи с графа БЕЗ ПОВТОРЕНИЙ (например "AB" и "BA" - одно и то же)
graph = [
    ["A", "C"], ["A", "D"], ["A", "G"],
    ["G", "D"], ["C", "D"],
    ["D", "B"], ["D", "E"],
    ["B", "F"], ["F", "E"]
]
# Переносим все пути из таблицы БЕЗ ПОВТОРЕНИЙ (для удобства в порядке возрастания)
table = [
    [1, 3], [1, 7],
    [2, 5], [2, 7],
    [3, 4], [3, 7],
    [4, 7],
    [5, 6],
    [6, 7]
]

for el in permutations("ABCDEFG"):  # Перебираем все возможные комбинации из элементов
    '''
    "for x, y in table" - Проходимся по всем элементам табличных данных и забираем по 2 числа
    "[el[x - 1], el[y - 1]] in graph  or [el[y - 1], el[x - 1]] in graph" - Подставляем вместо цифр соответствующие буквы
    и проверяем, если ли такой список на графе (рассматриваем 2 случая: например, "AB" и "BA", так как мы их исключали при добавлении в массивы)
    "all(...)" - Проверяет, всегда ли выражение внутри выдаёт истину
    '''
    if all([[el[x - 1], el[y - 1]] in graph or [el[y - 1], el[x - 1]] in graph for x, y in table]):
        print(sorted([el.index("B") + 1, el.index("E") + 1]))  # Выводим ответ: номера "В" и "Е" в порядке возрастания
